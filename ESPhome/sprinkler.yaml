esphome:
  name: sprinkler-1
  friendly_name: "Sprinkler"
  # Safety: Force relay OFF immediately when the chip starts
  on_boot:
    priority: 1000
    then:
      - output.turn_off: relay_pin
      - lambda: 'id(sprinkler_logic_switch).publish_state(false);'

esp32:
  board: esp32-c3-devkitm-1

# Enable logging for diagnostics (e.g., to see "Execution blocked" messages)
logger:
  level: DEBUG

# Global variable to prevent rapid re-triggering (Anti-spam protection)
globals:
  - id: cooldown_active
    type: bool
    restore_value: no
    initial_value: 'false'

wifi:
  ssid: "YOUR_SSID"
  password: "YOUR_PASSWORD"
  ap:
    ssid: "Sprinkler Fallback"

api:
ota:
  platform: esphome

# 1. Hardware Output (Relay)
output:
  - platform: gpio
    pin: 
      number: 8
      mode:
        output: true
        open_drain: true
    id: relay_pin
    # Set to 'false' for Active-High relay modules
    inverted: true

# 2. Watering Duration Slider
number:
  - platform: template
    name: "Watering Duration"
    id: water_duration
    optimistic: true
    min_value: 3
    max_value: 12
    step: 1
    initial_value: 3
    unit_of_measurement: "sec"
    icon: "mdi:timer-sand"
    mode: slider

# 3. Main Control Switch
switch:
  - platform: template
    name: "Sprinkler Switch"
    id: sprinkler_logic_switch
    icon: "mdi:water-pump"
    turn_on_action:
      - if:
          condition:
            # Check if script is NOT running and NOT in cooldown
            lambda: |-
              return !id(water_cycle_script).is_running() && !id(cooldown_active);
          then:
            - script.execute: water_cycle_script
          else:
            # If blocked, force the UI switch back to OFF
            - lambda: 'id(sprinkler_logic_switch).publish_state(false);'
            - logger.log: "Execution blocked: Cool-down active or script already running"
    turn_off_action:
      # Manual emergency stop sequence
      - script.stop: water_cycle_script
      - output.turn_off: relay_pin
      - delay: 50ms
      - output.turn_off: relay_pin
      - lambda: 'id(sprinkler_logic_switch).publish_state(false);'

# 4. Core Watering Logic Script
script:
  - id: water_cycle_script
    mode: single 
    then:
      # --- START ---
      - output.turn_on: relay_pin
      - lambda: 'id(sprinkler_logic_switch).publish_state(true);'
      
      # --- WAIT ---
      - delay: !lambda "return id(water_duration).state * 1000;"
      
      # --- TRIPLE STOP SEQUENCE (To counter EMI/Noise) ---
      - output.turn_off: relay_pin     # 1st attempt
      - delay: 100ms
      - output.turn_off: relay_pin     # 2nd attempt (after spike settles)
      - lambda: 'id(sprinkler_logic_switch).publish_state(false);'
      - delay: 100ms
      - output.turn_off: relay_pin     # 3rd attempt (hardware insurance)
      
      # --- COOLDOWN PERIOD ---
      - lambda: 'id(cooldown_active) = true;'
      - logger.log: "Cool-down interval started"
      
      - delay: 5s
      
      - lambda: 'id(cooldown_active) = false;'
      - logger.log: "Cool-down interval finished"
      
      # Final state synchronization
      - lambda: 'id(sprinkler_logic_switch).publish_state(false);'
